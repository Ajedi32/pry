#!/usr/bin/env ruby

# (C) John Mair (banisterfiend)
# MIT license

begin
  require 'pry'
rescue LoadError
  require 'rubygems'
  require 'pry'
end
require 'optparse'

# defaults
options = {
  :context_string => "TOPLEVEL_BINDING",
  :loadrc => true
}

OptionParser.new do |opts|
  opts.banner = %{Usage: pry [OPTIONS] 
Start a Pry session.
See: `https://github.com/banister` for more information.
--
}
  opts.on("-r", "--require FILE", "`require` a Ruby script at startup.") do |file|
    require file
  end

  opts.on("-e", "--exec CODE", "A line of Ruby code to execute in context before the session starts.") do |code|
    options[:code] = code
  end

  opts.on("-f", "Suppress loading of ~/.pryrc") do 
    options[:loadrc] = false
  end

  opts.on("--no-color", "Start session without syntax highlighting.") do 
    Pry.color = false
  end

  opts.on("--simple-prompt", "Simple prompt mode.") do 
    Pry.prompt = Pry::SIMPLE_PROMPT
  end

  opts.on("-I LOADPATH", "Specify $LOAD_PATH directory.") do  |load_path|
    $LOAD_PATH << load_path
  end

  opts.on("-v", "--version", "Display the Pry version.") do
    puts "Pry version #{Pry::VERSION} on Ruby #{RUBY_VERSION}"
    exit
  end

  opts.on("-c", "--context CONTEXT",
          "Start the session in the specified context. Equivalent to `context.pry` in a session.") do |context|

    # save the context name
    options[:context_string] = context
  end

  opts.on_tail("-h", "--help", "This message.") do 
    puts opts
    exit
  end
end.parse!

# invoked via cli
Pry.cli = true

class Pry::Commands
  command "reset", "Reset the REPL to a clean state." do
    output.puts "Pry reset."
    exec("pry")
  end
end

# load ~/.pryrc, if not suppressed with -f option
Pry.should_load_rc = false if !options[:loadrc]

# create the actual context
context = Pry.binding_for(eval(options[:context_string]))

# run code passed with `-e`, if there is any.
if options[:code]
  Pry.new(:input => StringIO.new(options[:code]), :print => proc {}).rep(context)
end

# start the session
context.pry
